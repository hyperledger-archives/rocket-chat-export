'use strict';

var util = require('util');

var helper = require('./helper');
var admin = require('./enrollAdmin');
var prettyjson = require('prettyjson');

var invokeChaincode = function(peerNames, channelName, chaincodeName, fcn, args, username, org) {
    console.log(util.format('============== Invoke transaction on organization %s ==============\n', org));
    var client = helper.getClientForOrg(org);
    var channel = helper.getChannelForOrg(org);
    var targets1 = (peerNames) ? helper.newPeers(peerNames, "org1") : undefined;
    targets1 = targets1[0];
    var targets2 = (peerNames) ? helper.newPeers(peerNames, "org2") : undefined;
    targets2 = targets2[0];
    var targets = [targets1,targets2];
    console.log(targets);

    var tx_id = null;
    var responsePayload = null;

    return admin.getAdminUser(org).then((user) => {
        tx_id = client.newTransactionID();
        console.log(util.format('Sending transaction "%j"', tx_id));
        // send proposal to endorser
        var request = {
            chaincodeId: chaincodeName,
            fcn: fcn,
            args: args,
            chainId: channelName,
            txId: tx_id
        };

        if (targets)
            request.targets = targets;

        channel.initialize();

        return channel.sendTransactionProposal(request);
    }, (err) => {
        console.log('Failed to enroll user \'' + username + '\'. ' + err);
        throw new Error('Failed to enroll user \'' + username + '\'. ' + err);
    }).then((results) => {
        var proposalResponses = results[0];

        console.log(channel.compareProposalResponseResults(proposalResponses));


        var proposal = results[1];


        var header = results[2];

        var all_good = true;

        for (var i in proposalResponses) {
            console.log("status=> " + i);


            let one_good = false;
            if (proposalResponses && proposalResponses[i].response &&
                proposalResponses[i].response.status === 200) {
                one_good = true;

                console.log('Peer ' + i + ' ' + channel.verifyProposalResponse(proposalResponses[i]));

                console.log('Peer ' + i + ': Transaction proposal was good');
            } else {
                console.log('Peer ' + i + ': Transaction proposal was bad');
            }
            all_good = all_good & one_good;
        }
        if (all_good) {
            // console.log(util.format(
            //     'Successfully sent Proposal and received ProposalResponse: \nStatus - %s \nMessage - "%s" \nMetadata : ',
            //     proposalResponses[0].response.status, proposalResponses[0].response.message));
            responsePayload = proposalResponses[0].response.payload.toString();
            var consolePrint = {
                Status: proposalResponses[0].response.status,
                Message: proposalResponses[0].response.message,
                Metadata: JSON.parse(responsePayload)
            };
            console.log('Successfully sent Proposal and received ProposalResponse:');
            console.log(prettyjson.render(consolePrint, null)+'\n');
            var request = {
                proposalResponses: proposalResponses,
                proposal: proposal,
                header: header
            };
            if (targets)
                request.targets = targets;
            // set the transaction listener and set a timeout of 30sec
            // if the transaction did not get committed within the timeout period,
            // fail the test
            var transactionID = tx_id.getTransactionID();
            var eventPromises = [];

            if (!peerNames) {
                peerNames = channel.getPeers().map(function(peer) {
                    return peer.getName();
                });
            }
            // only one peer of one org (for peer0 of both orgs)
            var peerName = [peerNames[0]];

            var eventhubs1 = helper.newEventHubs(peerName, "org1");
            var eventhubs2 = helper.newEventHubs(peerName, "org2");
            var eventhubs = eventhubs1.concat(eventhubs2);

            for (let key in eventhubs) {
                let eh = eventhubs[key];
                eh.connect();

                let txPromise = new Promise((resolve, reject) => {
                    let handle = setTimeout(() => {
                        eh.disconnect();
                        reject();
                    }, 30000);

                    eh.registerTxEvent(transactionID, (tx, code) => {
                        clearTimeout(handle);
                        eh.unregisterTxEvent(transactionID);
                        eh.disconnect();
                        if (code !== 'VALID') {
                            console.log(
                                'The transaction was invalid, code = ' + code);
                            reject();
                        } else {
                            console.log(
                                'The transaction has been committed on peer ' +
                                eh._ep._endpoint.addr);
                            resolve();
                        }
                    });
                });
                eventPromises.push(txPromise);
            };
            var sendPromise = channel.sendTransaction(request);
            console.log('Sent transaction to the orderer.');

            return Promise.all([sendPromise].concat(eventPromises)).then((results) => {
                console.log('Event promise all complete and testing complete');
            return results[0]; // the first returned value is from the 'sendPromise' which is from the 'sendTransaction()' call
        }).catch((err) => {
                console.log(
                'Failed to send transaction and get notifications within the timeout period.'
            );
            return 'Failed to send transaction and get notifications within the timeout period.';
        });
        } else {
            console.log(
                'Failed to send Proposal or receive valid response. Response null or status is not 200. exiting...'
            );
            return 'Failed to send Proposal or receive valid response. Response null or status is not 200. exiting...';
        }
    }, (err) => {
        console.log('Failed to send proposal due to error: ' + err.stack ? err.stack :
            err);
        return 'Failed to send proposal due to error: ' + err.stack ? err.stack :
            err;
    }).then((response) => {
        if (response.status === 'SUCCESS') {
            console.log('Transaction has been added to Blockchain!');
            console.log('=====================================================================\n')
            //console.log(response);

            var responseResult = {
                status : response.status,
                payload : JSON.parse(responsePayload),
                txID : tx_id.getTransactionID()
            };
            return responseResult;
        } else {
            console.log('Failed to order the transaction. Error code: ' + response.status);
            var responseResult = {
                status : 'FAILED',
                payload : "",
                txID : null
            };
            return responseResult;
        }
    }, (err) => {
        console.log('Failed to send transaction due to error: ' + err.stack ? err
            .stack : err);
        return 'Failed to send transaction due to error: ' + err.stack ? err.stack :
            err;
    });
};

exports.invokeChaincode = invokeChaincode;
