{"msg":"@bur here you go","username":"rjones","ts":"2021-04-23T15:51:21.705Z"}
{"msg":"Has joined the channel.","username":"bur","ts":"2021-04-23T15:51:21.794Z","type":"uj"}
{"msg":"bur","username":"rjones","ts":"2021-04-23T15:51:30.688Z","type":"subscription-role-added"}
{"msg":"Has joined the channel.","username":"matopavlovic","ts":"2021-04-23T21:00:36.786Z","type":"uj"}
{"msg":"Thank you!","username":"matopavlovic","ts":"2021-04-23T21:01:22.438Z"}
{"msg":"Has joined the channel.","username":"vukolic","ts":"2021-04-26T08:44:45.875Z","type":"uj"}
{"msg":"Has joined the channel.","username":"sigma67","ts":"2021-04-29T09:05:02.684Z","type":"uj"}
{"msg":"Has joined the channel.","username":"harrymknight","ts":"2021-05-11T10:07:57.197Z","type":"uj"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n`func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...`\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added as seen below\n`func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}` \nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n\n`func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...`\n\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added as seen below\n\n`func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}` \n\nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n\n`func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...`\n\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added? As seen below\n\n`func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}` \n\nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n\n```func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...```\n\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added? As seen below\n\n```func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}``` \n\nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n\n```func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...```\n\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added? As seen below\n\n```func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}``` \n\nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure. However it is clear that this action is not deprecated since it produced by the state machine in response to a fetch request.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Are messages of type ForwardRequest deprecated in regard to the state machine? I notice that in this block of code located in state_machine.go\n\n```func (sm *StateMachine) step(source nodeID, msg *msgs.Msg) *ActionList {\n\tactions := &ActionList{}\n\tswitch msg.Type.(type) {\n\tcase *msgs.Msg_RequestAck:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_FetchRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n\tcase *msgs.Msg_ForwardRequest:\n\t\treturn actions.concat(sm.clientHashDisseminator.step(source, msg))\n...```\n\nthe case for a message of type ForwardRequest is dealt with yet the step method of clientHashDisseminator doesn't account for it instead raising an error. Furthermore this type of message only seems to produced by a replica i.e. it is never produced internally by the state machine, and has an accompanying comment that indicates so.\n\nSo in regard to request forwarding (of transactions to be ordered) is it only the execution of an action of type forward request that has to be added? As seen below\n\n```func (pi *WorkItems) AddStateMachineResults(actions *statemachine.ActionList) {\n\t// First we'll handle everything that's not a network send\n\titer := actions.Iterator()\n\tfor action := iter.Next(); action != nil; action = iter.Next() {\n\t\tswitch t := action.Type.(type) {\n\t\tcase *state.Action_Send:\n\t\t\twalDependent := false\n\t\t\t// TODO, make sure this switch captures all the safe ones\n\t\t\tswitch t.Send.Msg.Type.(type) {\n\t\t\tcase *msgs.Msg_RequestAck:\n\t\t\tcase *msgs.Msg_Checkpoint:\n\t\t\tcase *msgs.Msg_FetchBatch:\n\t\t\tcase *msgs.Msg_ForwardBatch:\n\t\t\tdefault:\n\t\t\t\twalDependent = true\n\t\t\t}\n\t\t\tif walDependent {\n\t\t\t\tpi.WALActions().PushBack(action)\n\t\t\t} else {\n\t\t\t\tpi.NetActions().PushBack(action)\n\t\t\t}\n\t\tcase *state.Action_Hash:\n\t\t\tpi.HashActions().PushBack(action)\n\t\tcase *state.Action_AppendWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_TruncateWriteAhead:\n\t\t\tpi.WALActions().PushBack(action)\n\t\tcase *state.Action_Commit:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_Checkpoint:\n\t\t\tpi.AppActions().PushBack(action)\n\t\tcase *state.Action_AllocatedRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_CorrectRequest:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\tcase *state.Action_StateApplied:\n\t\t\tpi.ClientActions().PushBack(action)\n\t\t\t// TODO, create replicas\n\t\tcase *state.Action_ForwardRequest:\n\t\t\t// XXX address\n\t\tcase *state.Action_StateTransfer:\n\t\t\tpi.AppActions().PushBack(action)\n\t\t}\n\t}\n}``` \n\nI guess here the action would be delegated to the net processor to make use of the link provided in processorConfig but I'm not entirely sure. However it is clear that this action is not deprecated since it is produced by the state machine in response to a fetch request.","username":"harrymknight","ts":"2021-05-11T10:07:57.611Z"}
{"msg":"Has left the channel.","username":"rjones","ts":"2021-05-11T21:36:09.017Z","type":"ul"}
{"msg":"Hi Harry, thanks for you interest in MirBFT! The request forwarding is indeed not yet implemented. The current plan is to take request forwarding out of the state machine in a separate module that deals with client requests. Currently a ForwardRequest message is not produced by any part of the code, in or outside the state machine. Also, the are rather big changes pending for the state machine code in general, but those will take a bit of time. What I do expect in a few days (hopefully next week) is a refactoring of the node and processor, putting some more order in the different modules (the state machine implementing the actual protocol will be one of these modules) with clearer responsibilities of each of the modules. That should shed more light on how and where request forwarding is to be implemented. Stay tuned!","username":"matopavlovic","ts":"2021-05-13T06:50:19.356Z"}
{"msg":"Has joined the channel.","username":"davidkel","ts":"2021-06-13T14:05:49.522Z","type":"uj"}
{"msg":"Has joined the channel.","username":"knagware9","ts":"2021-07-08T11:04:31.826Z","type":"uj"}
{"msg":"Has joined the channel.","username":"kthomas","ts":"2021-09-30T16:11:41.887Z","type":"uj"}
{"msg":"Hi @matopavlovic please can you indicate the current status of implementing WAL?","username":"kthomas","ts":"2021-09-30T16:11:42.390Z"}
{"msg":"Hi @kthomas , sorry for the late response. A basic wal WAL is implemented (https://github.com/hyperledger-labs/mirbft/tree/main/pkg/simplewal), but the documentation is still missing. That being said, the protocol does not yet properly make use of the WAL.","username":"matopavlovic","ts":"2021-11-29T15:58:21.096Z"}
{"msg":"Has joined the channel.","username":"mkaddoura","ts":"2022-03-02T21:46:05.726Z","type":"uj"}
{"msg":"Hi, I am trying to understand how MirBFT is used in blockchain. Because each block is verified and committed in parallel, how does the blockchain links the blocks? For example, how does a block compute and add the previous block's hash?","username":"mkaddoura","ts":"2022-03-02T22:33:29.862Z"}
{"msg":"Has left the channel.","username":"davidkel","ts":"2022-03-02T22:36:13.230Z","type":"ul"}
{"msg":"","username":"rjones","ts":"2022-03-09T03:03:28.498Z","type":"room_changed_topic"}
{"msg":"","username":"rjones","ts":"2022-03-09T03:03:28.512Z","type":"room_changed_description"}
{"msg":"","username":"rjones","ts":"2022-03-09T03:03:28.515Z","type":"room_changed_announcement"}
